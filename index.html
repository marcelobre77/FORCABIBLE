<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Forca Bíblica</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React and ReactDOM CDNs -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Babel CDN to transpile JSX in the browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        /* Ensure Inter font is used for consistency */
        body {
            font-family: 'Inter', sans-serif;
        }
        input, button, select, textarea {
            font-family: 'Inter', sans-serif;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // Import React hooks directly using standard ES6 import syntax
        // Babel will transpile this for the browser environment.
        const { useState, useEffect, useRef } = React;

        // Main App component for the Biblical Hangman game
        const App = () => {
            // State to store words for each team - Initialized as an array of objects
            const [teamWords, setTeamWords] = useState([{}, {}, {}]);
            // State to store guessed letters for each team - Initialized as an array of arrays
            const [guessedLetters, setGuessedLetters] = useState([[], [], []]);
            // State to track incorrect guesses for each team - Initialized as an array of numbers
            const [incorrectGuesses, setIncorrectGuesses] = useState([0, 0, 0]);
            // State for the current active team (0: Left, 1: Middle, 2: Right)
            const [currentTeamIndex, setCurrentTeamIndex] = useState(0);
            // State for game status (selecting, playing, won, lost, ended)
            const [gameStatus, setGameStatus] = useState('selecting'); // Start in selection mode
            // State for the message displayed to the user
            const [message, setMessage] = useState('');
            // Ref for the letter input field
            const letterInputRef = useRef(null);
            // Refs for the full guess input fields
            const fullGuessInputRefs = [useRef(null), useRef(null), useRef(null)];
            // New state for number of active players
            const [numPlayers, setNumPlayers] = useState(0);

            // Word lists for each category
            const wordCategories = {
                book: [
                    "Gênesis", "Êxodo", "Levítico", "Números", "Deuteronômio", "Josué", "Juízes", "Rute", "Samuel", "Reis",
                    "Crônicas", "Esdras", "Neemias", "Ester", "Jó", "Salmos", "Provérbios", "Eclesiastes", "Cânticos",
                    "Isaías", "Jeremias", "Lamentações", "Ezequiel", "Daniel", "Oséias", "Joel", "Amós", "Obadias",
                    "Jonas", "Miquéias", "Naum", "Habacuque", "Sofonias", "Ageu", "Zacarias", "Malaquias", "Mateus",
                    "Marcos", "Lucas", "João", "Atos", "Romanos", "Coríntios", "Gálatas", "Efésios", "Filipenses",
                    "Colossenses", "Tessalonicenses", "Timóteo", "Tito", "Filemom", "Hebreus", "Tiago", "Pedro",
                    "João", "Judas", "Apocalipse"
                ],
                name: [
                    "Jesus", "Moisés", "Davi", "Abraão", "Maria", "Pedro", "Paulo", "Ester", "Rute", "José",
                    "Adão", "Eva", "Noé", "Sara", "Isaque", "Rebeca", "Jacó", "Raquel", "Judá", "Benjamim",
                    "Samuel", "Saul", "Salomão", "Jonas", "Elias", "Eliseu", "João Batista", "Marta", "Maria Madalena",
                    "Nicodemos", "Zaqueu", "Barnabé", "Timóteo", "Baruque", "Absalão", "Balaão", "Sansão", "Gideão", "Débora",
                    "Miriam", "Jônatas", "Isaías", "Jeremias", "Ezequiel", "Daniel", "Noemi", "Boaz", "Jezabel", "Acabe"
                ],
                place: [
                    "Jerusalém", "Belém", "Nazaré", "Egito", "Canaã", "Roma", "Galiléia", "Jordão", "Jericó", "Samaria",
                    "Babilônia", "Ninive", "Éden", "Gólgota", "Getsemani", "Emaús", "Cafarnaum", "Efrata", "Berseba",
                    "Damasco", "Antioquia", "Éfeso", "Corinto", "Tessalônica", "Pérgamo", "Esmirna", "Sardes", // 'Filipos' removed
                    "Laodicéia", "Tiatira", "Pátmos", "Sodoma", "Gomorra", "Ur", "Harã", "Siquém", "Betel", "Hebrom"
                ]
            };

            // Helper function to remove accents and convert to lowercase for comparison
            const normalizeString = (str) => {
                return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase();
            };

            // Effect to focus on the letter input when the turn changes
            useEffect(() => {
                if (letterInputRef.current && gameStatus === 'playing') {
                    letterInputRef.current.focus();
                }
            }, [currentTeamIndex, gameStatus]);

            // Function to select unique words for a team
            const selectUniqueWords = (existingWords = []) => {
                const selected = {};
                for (const category of ['book', 'name', 'place']) {
                    const availableWords = wordCategories[category].filter(word => !existingWords.includes(normalizeString(word)));
                    if (availableWords.length === 0) {
                        console.warn(`No more unique words for category ${category}. Resetting word pool.`);
                        selected[category] = wordCategories[category][Math.floor(Math.random() * wordCategories[category].length)];
                    } else {
                        selected[category] = availableWords[Math.floor(Math.random() * availableWords.length)];
                    }
                    existingWords.push(normalizeString(selected[category])); // Add normalized word to existing words to prevent duplicates
                }
                return selected;
            };

            // Game initialization logic, now takes number of players
            const initializeGame = (playersCount = 3) => { // Default to 3 players if not specified
                setNumPlayers(playersCount);

                const newTeamWords = Array(playersCount).fill({}).map(() => ({}));
                const newGuessedLetters = Array(playersCount).fill([]).map(() => []);
                const newIncorrectGuesses = Array(playersCount).fill(0);
                const allUsedWords = [];

                // Assign words and initial states for each of the `playersCount` teams
                for (let i = 0; i < playersCount; i++) {
                    newTeamWords[i] = selectUniqueWords(allUsedWords);
                }

                setTeamWords(newTeamWords);
                setGuessedLetters(newGuessedLetters);
                setIncorrectGuesses(newIncorrectGuesses);
                setCurrentTeamIndex(0); // Start with the first team
                setGameStatus('playing');
                setMessage(`VAMOS COMEÇAR! TIME ${["ESQUERDO", "MEIO", "DIREITO"][0]}, SUA VEZ!`);

                // Clear input fields
                if (letterInputRef.current) letterInputRef.current.value = '';
                fullGuessInputRefs.forEach(ref => {
                    if (ref.current) ref.current.value = '';
                });
            };

            // Get the current team's data
            const currentWords = teamWords[currentTeamIndex];
            const currentGuessedLetters = guessedLetters[currentTeamIndex];
            const currentIncorrectGuesses = incorrectGuesses[currentTeamIndex];
            const currentTeamName = ["ESQUERDO", "MEIO", "DIREITO"][currentTeamIndex];


            // Mask the words with blanks for display, now returning an array of characters for individual display
            const getMaskedWord = (word, guessedLettersArray) => {
                if (!word || typeof word !== 'string' || !guessedLettersArray || !Array.isArray(guessedLettersArray)) {
                    return [];
                }
                return word.split('').map(char => {
                    const normalizedChar = normalizeString(char);
                    // If the normalized character is in guessed letters, or it's not an alphabet character, display the original char
                    return guessedLettersArray.includes(normalizedChar) || !/[a-zà-ú]/i.test(char) ? char.toUpperCase() : '_';
                });
            };

            // Check if a team has won (all words guessed)
            const checkWinWithSpecificGuessedLetters = (wordsOfTeam, specificGuessedLetters) => {
                if (!wordsOfTeam || typeof wordsOfTeam !== 'object' || !specificGuessedLetters || !Array.isArray(specificGuessedLetters)) {
                    return false;
                }
                return Object.values(wordsOfTeam).every(word =>
                    word.split('').every(char =>
                        !/[a-zà-ú]/i.test(char) || specificGuessedLetters.includes(normalizeString(char))
                    )
                );
            };

            // Function to reveal all words for a given team
            const revealAllWordsForTeam = (teamIdToReveal) => {
                const teamSpecificWords = teamWords[teamIdToReveal];
                if (!teamSpecificWords) return;

                const allLetters = new Set();
                Object.values(teamSpecificWords).forEach(word => {
                    word.split('').forEach(char => {
                        if (/[a-zà-ú]/i.test(char)) allLetters.add(normalizeString(char));
                    });
                });

                setGuessedLetters(prev => {
                    const newState = [...prev];
                    newState[teamIdToReveal] = Array.from(allLetters);
                    return newState;
                });
            };

            // Handle a letter guess
            const handleLetterGuess = (e) => {
                e.preventDefault();
                const inputLetter = letterInputRef.current.value; // Get original input for message
                const normalizedInputLetter = normalizeString(inputLetter); // Normalize for logic
                letterInputRef.current.value = ''; // Clear input

                if (!normalizedInputLetter || normalizedInputLetter.length !== 1 || !/[a-zà-ú]/.test(normalizedInputLetter)) {
                    setMessage('POR FAVOR, DIGITE UMA ÚNICA LETRA VÁLIDA.');
                    return;
                }
                if (currentGuessedLetters.includes(normalizedInputLetter)) {
                    setMessage(`A LETRA "${inputLetter.toUpperCase()}" JÁ FOI TENTADA. TENTE OUTRA.`);
                    return;
                }

                let letterFound = false;
                // Check if the normalized letter exists in any of the current team's words (normalized)
                for (const category in currentWords) {
                    if (normalizeString(currentWords[category]).includes(normalizedInputLetter)) {
                        letterFound = true;
                        break;
                    }
                }

                // Calculate the new state *before* setting it, so it can be used immediately
                const newGuessedLettersForCurrentTeam = [...currentGuessedLetters, normalizedInputLetter];
                let newIncorrectCountForCurrentTeam = currentIncorrectGuesses;
                if (!letterFound) {
                    newIncorrectCountForCurrentTeam = currentIncorrectGuesses + 1;
                }

                // Update states. These calls schedule a re-render.
                // This makes the visual update (letters appearing, hangman parts) immediate.
                setGuessedLetters(prev => {
                    const newState = [...prev];
                    newState[currentTeamIndex] = newGuessedLettersForCurrentTeam;
                    return newState;
                });
                setIncorrectGuesses(prev => {
                    const newState = [...prev];
                    newState[currentTeamIndex] = newIncorrectCountForCurrentTeam;
                    return newState;
                });

                // Determine next game state and message based on the *immediate* outcome
                let finalMessage = '';
                let nextGameStatus = 'playing';

                if (newIncorrectCountForCurrentTeam >= 7) { // Prioritize loss
                    finalMessage = `TIME ${currentTeamName} PERDEU! AS PALAVRAS ERAM: LIVRO: "${currentWords.book.toUpperCase()}", NOME: "${currentWords.name.toUpperCase()}", LUGAR: "${currentWords.place.toUpperCase()}".`;
                    nextGameStatus = 'lost';
                    revealAllWordsForTeam(currentTeamIndex); // Reveal words for this losing team
                } else if (checkWinWithSpecificGuessedLetters(currentWords, newGuessedLettersForCurrentTeam)) { // Check win if not lost
                    finalMessage = `PARABÉNS! TIME ${currentTeamName} ADIVINHOU TODAS AS SUAS PALAVRAS E VENCEU O JOGO!`;
                    nextGameStatus = 'won';
                } else { // Game continues
                    finalMessage = `"${inputLetter.toUpperCase()}" ${letterFound ? 'ESTÁ CORRETO!' : 'ESTÁ INCORRETO. VOCÊ TEM ' + (7 - newIncorrectCountForCurrentTeam) + ' CHANCES RESTANTES.'}`;
                }

                setMessage(finalMessage); // Set message immediately

                // Defer game status update and turn switch to allow message to be seen
                setTimeout(() => {
                    if (nextGameStatus !== 'playing') {
                        setGameStatus(nextGameStatus);
                        // If game ends due to win or loss, check if overall game is over
                        if (nextGameStatus === 'won') {
                             for (let i = 0; i < numPlayers; i++) {
                                 if (i !== currentTeamIndex) { // If not the winning team
                                     revealAllWordsForTeam(i);
                                 }
                             }
                        }
                        const activeTeamsLeft = Array.from({ length: numPlayers }, (_, i) => i).filter(id =>
                            !checkWinWithSpecificGuessedLetters(teamWords[id], guessedLetters[id]) && incorrectGuesses[id] < 7
                        );
                        if (activeTeamsLeft.length === 0) {
                            setGameStatus('ended');
                            setMessage('FIM DE JOGO! NENHUM TIME VENCEU OU TODOS PERDERAM.');
                            for (let i = 0; i < numPlayers; i++) {
                                if (!checkWinWithSpecificGuessedLetters(teamWords[i], guessedLetters[i])) { // If not won
                                    revealAllWordsForTeam(i);
                                }
                            }
                        } else if (nextGameStatus === 'lost') { // If it was a loss, and there are still active teams, switch turn
                            switchTurn();
                        }
                    } else {
                        switchTurn(); // If game is still playing, switch turn
                    }
                }, nextGameStatus === 'playing' ? 500 : 1000); // Shorter delay for regular turns, longer for win/loss
            };

            // Handle "I know the answer" full guess
            const handleFullGuess = (e) => {
                e.preventDefault();
                const guessedBook = fullGuessInputRefs[0].current.value;
                const guessedName = fullGuessInputRefs[1].current.value;
                const guessedPlace = fullGuessInputRefs[2].current.value;

                fullGuessInputRefs.forEach(ref => {
                    if (ref.current) ref.current.value = ''; // Clear input
                });

                const normalizedGuessedBook = normalizeString(guessedBook);
                const normalizedGuessedName = normalizeString(guessedName);
                const normalizedGuessedPlace = normalizeString(guessedPlace);

                const correctBook = normalizeString(currentWords.book);
                const correctName = normalizeString(currentWords.name);
                const correctPlace = normalizeString(currentWords.place);

                let outcomeMessage = '';
                let newGameStatus = 'playing';

                if (normalizedGuessedBook === correctBook && normalizedGuessedName === correctName && normalizedGuessedPlace === correctPlace) {
                    // Reveal all letters for the current team if correct
                    revealAllWordsForTeam(currentTeamIndex);
                    outcomeMessage = `PARABÉNS! TIME ${currentTeamName} ADIVINHOU TODAS AS SUAS PALAVRAS E VENCEU O JOGO!`;
                    newGameStatus = 'won';
                } else { // Immediately lose if any guess is incorrect
                    setIncorrectGuesses(prev => {
                        const newState = [...prev];
                        newState[currentTeamIndex] = 7; // Set incorrect guesses to max
                        return newState;
                    });
                    outcomeMessage = `RESPOSTA INCORRETA! TIME ${currentTeamName} PERDEU IMEDIATAMENTE! AS PALAVRAS ERAM: LIVRO: "${currentWords.book.toUpperCase()}", NOME: "${currentWords.name.toUpperCase()}", LUGAR: "${currentWords.place.toUpperCase()}".`;
                    newGameStatus = 'lost';
                    revealAllWordsForTeam(currentTeamIndex); // Reveal words for this losing team
                }

                setMessage(outcomeMessage); // Set message immediately

                // Defer game status update and turn switch
                setTimeout(() => {
                    if (newGameStatus !== 'playing') {
                        setGameStatus(newGameStatus);
                        // If game ends due to win or loss, check if overall game is over
                        if (newGameStatus === 'won') {
                             for (let i = 0; i < numPlayers; i++) {
                                 if (i !== currentTeamIndex) { // If not the winning team
                                     revealAllWordsForTeam(i);
                                 }
                             }
                        }
                        const activeTeamsLeft = Array.from({ length: numPlayers }, (_, i) => i).filter(id =>
                            !checkWinWithSpecificGuessedLetters(teamWords[id], guessedLetters[id]) && incorrectGuesses[id] < 7
                        );
                        if (activeTeamsLeft.length === 0) {
                            setGameStatus('ended');
                            setMessage('FIM DE JOGO! NENHUM TIME VENCEU OU TODOS PERDERAM.');
                            for (let i = 0; i < numPlayers; i++) {
                                if (!checkWinWithSpecificGuessedLetters(teamWords[i], guessedLetters[i])) { // If not won
                                    revealAllWordsForTeam(i);
                                }
                            }
                        } else if (newGameStatus === 'lost') { // If it was a loss, and there are still active teams, switch turn
                            switchTurn();
                        }
                    } else {
                        switchTurn(); // If game is still playing, switch turn
                    }
                }, 1000); // Always give a bit more time for full guess outcome
            };

            // Switch to the next team's turn
            const switchTurn = () => {
                if (gameStatus !== 'playing') return;

                let nextTeam = (currentTeamIndex + 1) % numPlayers;
                let originalStartingNextTeam = nextTeam;

                // Skip teams that have already won or lost (hanged)
                while ((checkWinWithSpecificGuessedLetters(teamWords[nextTeam], guessedLetters[nextTeam]) || incorrectGuesses[nextTeam] >= 7)) {
                    nextTeam = (nextTeam + 1) % numPlayers;
                    if (nextTeam === originalStartingNextTeam) {
                        const activeTeams = Array.from({ length: numPlayers }, (_, i) => i).filter(id =>
                            !checkWinWithSpecificGuessedLetters(teamWords[id], guessedLetters[id]) && incorrectGuesses[id] < 7
                        );
                        if (activeTeams.length === 0) {
                            setGameStatus('ended');
                            setMessage('FIM DE JOGO! NENHUM TIME VENCEU OU TODOS PERDERAM.');
                            for (let i = 0; i < numPlayers; i++) {
                                if (!checkWinWithSpecificGuessedLetters(teamWords[i], guessedLetters[i])) {
                                    revealAllWordsForTeam(i);
                                }
                            }
                            return;
                        } else if (activeTeams.length === 1 && activeTeams[0] === currentTeamIndex) {
                            setMessage(`TIME ${currentTeamName}, SUA VEZ!`);
                            return;
                        }
                        break;
                    }
                }
                setCurrentTeamIndex(nextTeam);
                setMessage(`TIME ${["ESQUERDO", "MEIO", "DIREITO"][nextTeam]}, SUA VEZ!`);
            };


            // Hangman SVG drawing based on incorrect guesses
            const HangmanSVG = ({ incorrectCount }) => {
                const parts = [
                    // Head
                    <circle key="head" cx="100" cy="50" r="20" stroke="currentColor" strokeWidth="2" fill="none" />,
                    // Body (a more blocky style)
                    <rect key="body" x="95" y="70" width="10" height="50" fill="#3B82F6" stroke="currentColor" strokeWidth="2" rx="3" ry="3"/>,
                    // Left Arm (more defined shapes)
                    <rect key="left-arm" x="65" y="80" width="30" height="10" fill="#FCD34D" stroke="currentColor" strokeWidth="1" rx="3" ry="3"/>,
                    // Right Arm
                    <rect key="right-arm" x="105" y="80" width="30" height="10" fill="#FCD34D" stroke="currentColor" strokeWidth="1" rx="3" ry="3"/>,
                    // Left Leg - Adjusted y to be closer to body (was 130, now 120)
                    <rect key="left-leg" x="85" y="120" width="10" height="30" fill="#10B981" stroke="currentColor" strokeWidth="1" rx="3" ry="3"/>,
                    // Right Leg - Adjusted y to be closer to body (was 130, now 120)
                    <rect key="right-leg" x="105" y="120" width="10" height="30" fill="#10B981" stroke="currentColor" strokeWidth="1" rx="3" ry="3"/>,
                    // Hair/Face Detail (7th part - X eyes and simple mouth/hair)
                    <g key="face-detail">
                        <line x1="90" y1="40" x2="85" y2="45" stroke="#4B5563" strokeWidth="1" /> {/* Left eye X */}
                        <line x1="85" y1="40" x2="90" y2="45" stroke="#4B5563" strokeWidth="1" />
                        <line x1="110" y1="40" x2="105" y2="45" stroke="#4B5563" strokeWidth="1" /> {/* Right eye X */}
                        <line x1="105" y1="40" x2="110" y2="45" stroke="#4B5563" strokeWidth="1" />
                        <path d="M95 55 Q100 60 105 55" stroke="#4B5563" strokeWidth="1" fill="none" /> {/* Mouth */}
                        <path d="M85 35 C80 30, 90 25, 95 30 S105 25, 110 30 C120 25, 115 30, 110 35" fill="brown" stroke="brown" strokeWidth="0.5" /> {/* Simple hair */}
                    </g>
                ];

                return (
                    <svg className="w-24 h-40" viewBox="0 0 200 200">
                        {/* Gallow */}
                        <line x1="10" y1="190" x2="100" y2="190" stroke="currentColor" strokeWidth="4" />
                        <line x1="55" y1="190" x2="55" y2="10" stroke="currentColor" strokeWidth="4" />
                        <line x1="55" y1="10" x2="100" y2="10" stroke="currentColor" strokeWidth="4" />
                        <line x1="100" y1="10" x2="100" y2="30" stroke="currentColor" strokeWidth="2" />
                        {/* Drawn parts based on incorrectCount */}
                        {parts.slice(0, incorrectCount)}
                    </svg>
                );
            };

            return (
                <div className="min-h-screen bg-gradient-to-br from-blue-100 to-indigo-200 p-4 font-inter text-gray-800 flex flex-col items-center justify-center">
                    <header className="text-center mb-8">
                        <p className="text-xl text-indigo-600 mt-2 font-semibold italic">JOGO DESENVOLVIDO PELO DR. MARCELO BRENDON</p>
                        <h1 className="text-5xl font-extrabold text-indigo-700 drop-shadow-lg rounded-xl p-2 uppercase">FORCA BÍBLICA</h1>
                        <p className="text-xl text-indigo-600 mt-2 font-semibold uppercase">LIVRO, NOME E LUGAR</p>
                    </header>

                    {/* Game Status Message */}
                    {message && (
                        <div className={`mb-6 p-4 rounded-xl shadow-lg text-center font-bold text-lg ${
                            gameStatus === 'won' ? 'bg-green-500 text-white' :
                            gameStatus === 'lost' || gameStatus === 'ended' ? 'bg-red-500 text-white' : // Red for lost or ended
                            'bg-white text-indigo-700'
                        }`}>
                            {message}
                        </div>
                    )}

                    {/* Game Mode Selection Screen */}
                    {gameStatus === 'selecting' && (
                        <div className="mt-8 p-6 bg-white rounded-3xl shadow-2xl border-4 border-indigo-600 w-full max-w-lg flex flex-col items-center justify-center">
                            <h3 className="text-3xl font-bold text-center text-indigo-700 mb-6 uppercase">SELECIONE O MODO DE JOGO</h3>
                            <button
                                onClick={() => initializeGame(1)}
                                className="bg-gradient-to-r from-blue-500 to-indigo-600 text-white font-bold py-4 px-10 rounded-xl shadow-lg hover:shadow-xl transform hover:scale-105 transition duration-300 text-xl uppercase mb-4 w-full"
                            >
                                JOGO SOLO (1 FORCA)
                            </button>
                            <button
                                onClick={() => initializeGame(2)}
                                className="bg-gradient-to-r from-purple-500 to-pink-600 text-white font-bold py-4 px-10 rounded-xl shadow-lg hover:shadow-xl transform hover:scale-105 transition duration-300 text-xl uppercase mb-4 w-full"
                            >
                                DUELO (2 FORCAS)
                            </button>
                            <button
                                onClick={() => initializeGame(3)}
                                className="bg-gradient-to-r from-teal-500 to-green-600 text-white font-bold py-4 px-10 rounded-xl shadow-lg hover:shadow-xl transform hover:scale-105 transition duration-300 text-xl uppercase w-full"
                            >
                                DISPUTA (3 FORCAS)
                            </button>
                        </div>
                    )}

                    {/* Team Display Area - only rendered if gameStatus is not 'selecting' */}
                    {gameStatus !== 'selecting' && (
                        <div className={`grid grid-cols-1 gap-8 w-full max-w-6xl 
                            ${numPlayers === 2 ? 'md:grid-cols-2' : numPlayers === 3 ? 'md:grid-cols-3' : 'md:grid-cols-1'}`}>
                            {/* Map over teams to display their respective states based on numPlayers */}
                            {Array.from({ length: numPlayers }, (_, i) => i).map((teamId) => {
                                const teamSpecificWords = teamWords[teamId] || {}; // Ensure it's an object
                                const teamSpecificGuessedLetters = guessedLetters[teamId] || []; // Ensure it's an array
                                const teamSpecificIncorrectGuesses = incorrectGuesses[teamId] || 0; // Ensure it's a number

                                return (
                                    <div
                                        key={teamId}
                                        className={`p-6 rounded-3xl shadow-xl border-4 transition-all duration-300
                                            ${currentTeamIndex === teamId ? 'border-indigo-600 bg-white scale-105' : 'border-gray-300 bg-gray-50 opacity-70'}
                                            ${checkWinWithSpecificGuessedLetters(teamSpecificWords, teamSpecificGuessedLetters) ? 'bg-green-100 border-green-500' : ''}
                                            ${teamSpecificIncorrectGuesses >= 7 ? 'bg-red-100 border-red-500' : ''}
                                            ${numPlayers === 1 ? 'md:col-span-1' : numPlayers === 2 ? 'md:col-span-1' : ''} /* Adjust column span for solo/duelo */
                                        `}
                                    >
                                        <h2 className={`text-2xl font-bold mb-4 text-center ${currentTeamIndex === teamId ? 'text-indigo-700' : 'text-gray-600'} uppercase`}>
                                            TIME {["ESQUERDO", "MEIO", "DIREITO"][teamId]}
                                            {checkWinWithSpecificGuessedLetters(teamSpecificWords, teamSpecificGuessedLetters) && <span className="text-green-600 ml-2"> (VENCEU!)</span>}
                                            {teamSpecificIncorrectGuesses >= 7 && <span className="text-red-600 ml-2"> (PERDEU!)</span>}
                                        </h2>

                                        {/* Hangman drawing for each team */}
                                        <div className="flex justify-center mb-6">
                                            <HangmanSVG incorrectCount={teamSpecificIncorrectGuesses} />
                                        </div>

                                        <div className="mb-6 text-center text-lg font-mono">
                                            {/* Display masked words as individual cells */}
                                            {/* Adjusted size and nowrap for solo/duelo modes */}
                                            <p className="mb-2">LIVRO: <span className={`flex justify-center mt-2 
                                                ${numPlayers === 1 ? 'gap-2' : numPlayers === 2 ? 'gap-1.5' : 'gap-1'} 
                                                ${numPlayers <= 2 ? 'flex-nowrap overflow-x-auto' : 'flex-wrap'}`}>
                                                {getMaskedWord(teamSpecificWords.book, teamSpecificGuessedLetters).map((char, idx) => (
                                                    <span key={idx} className={`flex-shrink-0 flex items-center justify-center border-b-2 border-indigo-500 bg-indigo-100 rounded-md text-indigo-800 font-semibold 
                                                        ${numPlayers === 1 ? 'w-12 h-12 text-2xl' : numPlayers === 2 ? 'w-10 h-10 text-xl' : 'w-8 h-8 text-lg'}
                                                    `}>
                                                        {char}
                                                    </span>
                                                ))}
                                            </span></p>
                                            <p className="mb-2">NOME: <span className={`flex justify-center mt-2 
                                                ${numPlayers === 1 ? 'gap-2' : numPlayers === 2 ? 'gap-1.5' : 'gap-1'} 
                                                ${numPlayers <= 2 ? 'flex-nowrap overflow-x-auto' : 'flex-wrap'}`}>
                                                {getMaskedWord(teamSpecificWords.name, teamSpecificGuessedLetters).map((char, idx) => (
                                                    <span key={idx} className={`flex-shrink-0 flex items-center justify-center border-b-2 border-indigo-500 bg-indigo-100 rounded-md text-indigo-800 font-semibold 
                                                        ${numPlayers === 1 ? 'w-12 h-12 text-2xl' : numPlayers === 2 ? 'w-10 h-10 text-xl' : 'w-8 h-8 text-lg'}
                                                    `}>
                                                        {char}
                                                    </span>
                                                ))}
                                            </span></p>
                                            <p>LUGAR: <span className={`flex justify-center mt-2 
                                                ${numPlayers === 1 ? 'gap-2' : numPlayers === 2 ? 'gap-1.5' : 'gap-1'} 
                                                ${numPlayers <= 2 ? 'flex-nowrap overflow-x-auto' : 'flex-wrap'}`}>
                                                {getMaskedWord(teamSpecificWords.place, teamSpecificGuessedLetters).map((char, idx) => (
                                                    <span key={idx} className={`flex-shrink-0 flex items-center justify-center border-b-2 border-indigo-500 bg-indigo-100 rounded-md text-indigo-800 font-semibold 
                                                        ${numPlayers === 1 ? 'w-12 h-12 text-2xl' : numPlayers === 2 ? 'w-10 h-10 text-xl' : 'w-8 h-8 text-lg'}
                                                    `}>
                                                        {char}
                                                    </span>
                                                ))}
                                            </span></p>
                                        </div>

                                        <div className="text-center text-sm text-gray-600 mb-4 uppercase">
                                            LETRAS JÁ TENTADAS: <span className="font-semibold text-gray-800">{ (teamSpecificGuessedLetters).map(l => l.toUpperCase()).join(', ') }</span>
                                        </div>
                                    </div>
                                );
                            })}
                        </div>
                    )}

                    {/* Current Team's Input Area - only rendered if gameStatus is 'playing' */}
                    {gameStatus === 'playing' && (
                        <div className="mt-8 p-6 bg-white rounded-3xl shadow-2xl border-4 border-indigo-600 w-full max-w-lg">
                            <h3 className="text-3xl font-bold text-center text-indigo-700 mb-6 uppercase">
                                VEZ DO TIME {currentTeamName}
                            </h3>

                            {/* Guess Letter Form */}
                            <form onSubmit={handleLetterGuess} className="flex flex-col items-center mb-6">
                                <label htmlFor="letter-guess" className="text-lg font-medium text-gray-700 mb-4 uppercase">ADIVINHE UMA LETRA:</label>
                                <div className="w-32 h-32 bg-blue-600 rounded-full flex items-center justify-center shadow-xl border-4 border-blue-400 mb-6">
                                    <input
                                        type="text"
                                        id="letter-guess"
                                        ref={letterInputRef}
                                        maxLength="1"
                                        className="w-20 h-20 text-center text-5xl font-bold uppercase text-white bg-transparent outline-none border-none placeholder-blue-300"
                                        disabled={gameStatus !== 'playing' || checkWinWithSpecificGuessedLetters(currentWords, currentGuessedLetters) || currentIncorrectGuesses >= 7}
                                        placeholder="A" // Placeholder to suggest letter input
                                    />
                                </div>
                                <button
                                    type="submit"
                                    className="bg-gradient-to-r from-indigo-500 to-purple-600 text-white font-bold py-3 px-8 rounded-xl shadow-lg hover:shadow-xl transform hover:scale-105 transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed"
                                    disabled={gameStatus !== 'playing' || checkWinWithSpecificGuessedLetters(currentWords, currentGuessedLetters) || currentIncorrectGuesses >= 7}
                                >
                                    TENTAR LETRA
                                </button>
                            </form>

                            {/* Full Guess Form */}
                            <hr className="my-6 border-indigo-200" />
                            <form onSubmit={handleFullGuess} className="flex flex-col items-center">
                                <label className="text-lg font-medium text-gray-700 mb-4 text-center uppercase">OU, JÁ SABE A RESPOSTA?</label>
                                <input
                                    type="text"
                                    placeholder="LIVRO BÍBLICO"
                                    ref={fullGuessInputRefs[0]}
                                    className="w-full p-3 mb-3 text-center border-2 border-indigo-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-indigo-500 transition duration-200 uppercase"
                                    disabled={gameStatus !== 'playing' || checkWinWithSpecificGuessedLetters(currentWords, currentGuessedLetters) || currentIncorrectGuesses >= 7}
                                />
                                <input
                                    type="text"
                                    placeholder="NOME BÍBLICO"
                                    ref={fullGuessInputRefs[1]}
                                    className="w-full p-3 mb-3 text-center border-2 border-indigo-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-indigo-500 transition duration-200 uppercase"
                                    disabled={gameStatus !== 'playing' || checkWinWithSpecificGuessedLetters(currentWords, currentGuessedLetters) || currentIncorrectGuesses >= 7}
                                />
                                <input
                                    type="text"
                                    placeholder="LUGAR BÍBLICO"
                                    ref={fullGuessInputRefs[2]}
                                    className="w-full p-3 mb-4 text-center border-2 border-indigo-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-indigo-500 transition duration-200 uppercase"
                                    disabled={gameStatus !== 'playing' || checkWinWithSpecificGuessedLetters(currentWords, currentGuessedLetters) || currentIncorrectGuesses >= 7}
                                />
                                <button
                                    type="submit"
                                    className="bg-gradient-to-r from-green-500 to-teal-600 text-white font-bold py-3 px-8 rounded-xl shadow-lg hover:shadow-xl transform hover:scale-105 transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed"
                                    disabled={gameStatus !== 'playing' || checkWinWithSpecificGuessedLetters(currentWords, currentGuessedLetters) || currentIncorrectGuesses >= 7}
                                >
                                    JÁ SEI A RESPOSTA!
                                </button>
                            </form>
                        </div>
                    )}

                    {/* Restart and Zerar Tudo Buttons - displayed when game ends or is not in selection mode */}
                    {(gameStatus === 'won' || gameStatus === 'lost' || gameStatus === 'ended' || gameStatus === 'playing') && (
                        <div className="flex flex-col md:flex-row gap-4 mt-8">
                            {/* Restart Button */}
                            {(gameStatus === 'won' || gameStatus === 'lost' || gameStatus === 'ended') && (
                                <button
                                    onClick={() => initializeGame(numPlayers)} // Restart with current number of players
                                    className="bg-gradient-to-r from-yellow-500 to-orange-600 text-white font-bold py-4 px-10 rounded-xl shadow-xl hover:shadow-2xl transform hover:scale-105 transition duration-300 text-xl uppercase"
                                >
                                    JOGAR NOVAMENTE
                                </button>
                            )}
                            {/* "Zerar Tudo e Reiniciar" Button */}
                            <button
                                onClick={() => setGameStatus('selecting')} // Go back to game selection
                                className="bg-red-600 text-white font-bold py-3 px-8 rounded-xl shadow-lg hover:shadow-xl transform hover:scale-105 transition duration-300 text-lg uppercase"
                            >
                                ZERAR TUDO E REINICIAR
                            </button>
                        </div>
                    )}
                </div>
            );
        };

        // Render the App component into the root div
        const domNode = document.getElementById('root');
        const root = ReactDOM.createRoot(domNode);
        root.render(<App />);
    </script>
</body>
</html>
